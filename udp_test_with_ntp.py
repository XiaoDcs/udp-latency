#!/usr/bin/env python3
"""
无人机UDP通信测试系统 - 集成NTP时间同步
完整的测试启动脚本，包含时间同步、UDP发送/接收、GPS记录、状态监控等功能
"""

import os
import sys
import time
import json
import socket
import argparse
import subprocess
import threading
import logging
from datetime import datetime
from typing import Dict, Any, Optional, List

class NTPSyncManager:
    """NTP时间同步管理器"""
    
    def __init__(self, local_ip: str, peer_ip: str, log_path: str = "./logs"):
        self.local_ip = local_ip
        self.peer_ip = peer_ip
        self.log_path = log_path
        self.role = None  # 'server' or 'client'
        self.sync_status = {'synced': False, 'offset_ms': None}
        
        # 设置日志
        self.setup_logging()
        
    def setup_logging(self):
        """设置日志配置"""
        os.makedirs(self.log_path, exist_ok=True)
        log_file = os.path.join(self.log_path, f"ntp_sync_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log")
        
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
    
    def determine_role(self) -> str:
        """基于IP地址确定角色"""
        local_parts = [int(x) for x in self.local_ip.split('.')]
        peer_parts = [int(x) for x in self.peer_ip.split('.')]
        
        # 比较IP地址，较小的作为服务器
        if local_parts < peer_parts:
            self.role = 'server'
        else:
            self.role = 'client'
        
        self.logger.info(f"Role determined: {self.role} (local: {self.local_ip}, peer: {self.peer_ip})")
        return self.role
    
    def wait_for_peer(self, timeout: int = 30) -> bool:
        """等待对方无人机上线"""
        self.logger.info(f"Waiting for peer {self.peer_ip} to come online...")
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            try:
                # 尝试ping对方
                result = subprocess.run(['ping', '-c', '1', '-W', '1', self.peer_ip], 
                                      capture_output=True, timeout=5)
                if result.returncode == 0:
                    self.logger.info(f"Peer {self.peer_ip} is online")
                    return True
            except Exception as e:
                self.logger.debug(f"Error pinging peer: {e}")
            
            time.sleep(2)
        
        self.logger.warning(f"Peer {self.peer_ip} not reachable within {timeout}s")
        return False
    
    def install_chrony(self) -> bool:
        """安装chrony（如果需要）"""
        try:
            # 检查chrony是否已安装
            result = subprocess.run(['which', 'chronyc'], capture_output=True)
            if result.returncode == 0:
                self.logger.info("Chrony already installed")
                return True
            
            # 安装chrony
            self.logger.info("Installing chrony...")
            subprocess.run(['sudo', 'apt-get', 'update'], check=True)
            subprocess.run(['sudo', 'apt-get', 'install', '-y', 'chrony'], check=True)
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to install chrony: {e}")
            return False
    
    def configure_ntp_server(self) -> bool:
        """配置为NTP服务器"""
        config = f"""# NTP Server Configuration - Generated by UDP Test System
# 使用本地时钟作为时间源
server 127.127.1.0
fudge 127.127.1.0 stratum 8

# 允许客户端访问
allow {self.peer_ip}
allow 192.168.104.0/24

# 监听所有接口
bindaddress 0.0.0.0

# 日志配置
logdir /var/log/chrony
log measurements statistics tracking

# 其他配置
driftfile /var/lib/chrony/drift
makestep 1.0 3
rtcsync
"""
        return self.write_chrony_config(config)
    
    def configure_ntp_client(self) -> bool:
        """配置为NTP客户端"""
        config = f"""# NTP Client Configuration - Generated by UDP Test System
# 使用对方作为时间源
server {self.peer_ip} iburst prefer

# 快速同步配置
makestep 1.0 3
maxupdateskew 100.0

# 日志配置
logdir /var/log/chrony
log measurements statistics tracking

# 其他配置
driftfile /var/lib/chrony/drift
rtcsync
"""
        return self.write_chrony_config(config)
    
    def write_chrony_config(self, config: str) -> bool:
        """写入chrony配置文件"""
        try:
            # 备份原配置文件
            backup_file = f"/etc/chrony/chrony.conf.backup.{int(time.time())}"
            subprocess.run(['sudo', 'cp', '/etc/chrony/chrony.conf', backup_file], 
                         capture_output=True)
            
            # 写入新配置
            with open('/tmp/chrony.conf.new', 'w') as f:
                f.write(config)
            
            subprocess.run(['sudo', 'cp', '/tmp/chrony.conf.new', '/etc/chrony/chrony.conf'], 
                         check=True)
            
            # 重启chrony服务
            subprocess.run(['sudo', 'systemctl', 'restart', 'chrony'], check=True)
            time.sleep(3)  # 等待服务启动
            
            self.logger.info(f"Chrony configured as {self.role}")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to configure chrony: {e}")
            return False
    
    def verify_sync(self, timeout: int = 60) -> bool:
        """验证时间同步状态"""
        if self.role == 'server':
            return self.verify_server_status(timeout)
        else:
            return self.verify_client_sync(timeout)
    
    def verify_server_status(self, timeout: int) -> bool:
        """验证服务器状态"""
        start_time = time.time()
        while time.time() - start_time < timeout:
            try:
                result = subprocess.run(['chronyc', 'clients'], 
                                      capture_output=True, text=True, timeout=5)
                if self.peer_ip in result.stdout:
                    self.logger.info("NTP server: client connected successfully")
                    self.sync_status['synced'] = True
                    return True
                    
            except Exception as e:
                self.logger.debug(f"Error checking server status: {e}")
            
            time.sleep(5)
        
        self.logger.warning("NTP server: no clients connected within timeout")
        return False
    
    def verify_client_sync(self, timeout: int) -> bool:
        """验证客户端同步状态"""
        start_time = time.time()
        while time.time() - start_time < timeout:
            try:
                result = subprocess.run(['chronyc', 'sources', '-v'], 
                                      capture_output=True, text=True, timeout=5)
                lines = result.stdout.split('\n')
                for line in lines:
                    if '*' in line and self.peer_ip in line:
                        # 解析偏移量
                        parts = line.split()
                        if len(parts) >= 7:
                            offset = float(parts[6])  # 偏移量（秒）
                            offset_ms = offset * 1000
                            self.sync_status['offset_ms'] = offset_ms
                            
                            if abs(offset_ms) < 10:  # 10ms以内认为同步成功
                                self.logger.info(f"NTP client synced successfully, offset: {offset_ms:.2f}ms")
                                self.sync_status['synced'] = True
                                return True
                            else:
                                self.logger.info(f"NTP client syncing, current offset: {offset_ms:.2f}ms")
                
            except Exception as e:
                self.logger.debug(f"Error checking sync status: {e}")
            
            time.sleep(5)
        
        self.logger.error("Failed to achieve time sync within timeout")
        return False
    
    def get_sync_status(self) -> Dict[str, Any]:
        """获取当前同步状态"""
        if self.role == 'client':
            try:
                result = subprocess.run(['chronyc', 'sources', '-v'], 
                                      capture_output=True, text=True, timeout=5)
                lines = result.stdout.split('\n')
                for line in lines:
                    if '*' in line and self.peer_ip in line:
                        parts = line.split()
                        if len(parts) >= 7:
                            offset = float(parts[6]) * 1000  # 转换为毫秒
                            self.sync_status['offset_ms'] = offset
                            self.sync_status['synced'] = abs(offset) < 10
                            break
            except Exception:
                pass
        
        return self.sync_status.copy()
    
    def setup_time_sync(self) -> bool:
        """设置时间同步"""
        try:
            # 1. 安装chrony
            if not self.install_chrony():
                return False
            
            # 2. 确定角色
            role = self.determine_role()
            print(f"This drone will act as NTP {role}")
            
            # 3. 等待对方上线
            if not self.wait_for_peer():
                print("Warning: Peer not reachable, proceeding anyway...")
            
            # 4. 配置NTP
            if role == 'server':
                success = self.configure_ntp_server()
            else:
                success = self.configure_ntp_client()
            
            if not success:
                return False
            
            # 5. 验证同步
            if self.verify_sync():
                print(f"✓ Time synchronization successful! Role: {role}")
                return True
            else:
                print("✗ Time synchronization failed!")
                return False
                
        except Exception as e:
            self.logger.error(f"NTP setup failed: {e}")
            return False


class UDPTestManager:
    """UDP测试管理器"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.log_path = config.get('log_path', './logs')
        self.mode = config.get('mode', 'sender')  # 'sender' or 'receiver'
        
        # 创建日志目录
        os.makedirs(self.log_path, exist_ok=True)
        
        # 设置日志
        self.setup_logging()
        
        # 初始化NTP管理器
        local_ip = config.get('local_ip', '192.168.104.10')
        peer_ip = config.get('peer_ip', '192.168.104.20')
        self.ntp_manager = NTPSyncManager(local_ip, peer_ip, self.log_path)
        
        # 状态监控
        self.monitoring = False
        self.monitor_thread = None
        
        # GPS记录器进程
        self.gps_process = None
        self.enable_gps = config.get('enable_gps', False)
        self.drone_id = config.get('drone_id', 'drone0')
        self.gps_interval = config.get('gps_interval', 1.0)
    
    def setup_logging(self):
        """设置日志"""
        log_file = os.path.join(self.log_path, f"udp_test_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log")
        
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(f"{__name__}.UDPTestManager")
    
    def start_gps_logging(self) -> bool:
        """启动GPS记录器"""
        if not self.enable_gps:
            self.logger.info("GPS logging disabled")
            return True
            
        try:
            self.logger.info("Starting GPS logger...")
            
            # 构建GPS记录器命令
            cmd = [
                'python3', 'gps.py',
                '--drone-id', self.drone_id,
                '--log-path', self.log_path,
                '--interval', str(self.gps_interval),
                '--time', str(self.config.get('running_time', 3600)),
                '--verbose', 'true'
            ]
            
            # 如果使用仿真时间
            if self.config.get('use_sim_time', False):
                cmd.append('--sim-time')
            
            # 启动GPS记录器进程
            self.gps_process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            
            # 等待一下确保GPS记录器启动
            time.sleep(2)
            
            # 检查进程是否正常运行
            if self.gps_process.poll() is None:
                self.logger.info("GPS logger started successfully")
                return True
            else:
                stdout, stderr = self.gps_process.communicate()
                self.logger.error(f"GPS logger failed to start: {stderr}")
                return False
                
        except Exception as e:
            self.logger.error(f"Failed to start GPS logger: {e}")
            return False
    
    def stop_gps_logging(self):
        """停止GPS记录器"""
        if self.gps_process and self.gps_process.poll() is None:
            self.logger.info("Stopping GPS logger...")
            try:
                self.gps_process.terminate()
                self.gps_process.wait(timeout=10)
                self.logger.info("GPS logger stopped")
            except subprocess.TimeoutExpired:
                self.logger.warning("GPS logger did not stop gracefully, killing...")
                self.gps_process.kill()
                self.gps_process.wait()
            except Exception as e:
                self.logger.error(f"Error stopping GPS logger: {e}")
    
    def start_monitoring(self):
        """启动状态监控"""
        self.monitoring = True
        self.monitor_thread = threading.Thread(target=self._monitor_loop, daemon=True)
        self.monitor_thread.start()
        self.logger.info("Status monitoring started")
    
    def stop_monitoring(self):
        """停止状态监控"""
        self.monitoring = False
        if self.monitor_thread:
            self.monitor_thread.join(timeout=5)
        self.logger.info("Status monitoring stopped")
    
    def _monitor_loop(self):
        """监控循环"""
        while self.monitoring:
            try:
                # 获取NTP同步状态
                sync_status = self.ntp_manager.get_sync_status()
                
                # 检查GPS记录器状态
                gps_status = "running" if (self.gps_process and self.gps_process.poll() is None) else "stopped"
                
                # 记录状态
                status_info = {
                    'timestamp': datetime.now().isoformat(),
                    'ntp_role': self.ntp_manager.role,
                    'ntp_synced': sync_status.get('synced', False),
                    'ntp_offset_ms': sync_status.get('offset_ms'),
                    'gps_logger_status': gps_status,
                    'enable_gps': self.enable_gps,
                }
                
                # 写入监控日志
                monitor_file = os.path.join(self.log_path, "system_monitor.jsonl")
                with open(monitor_file, 'a') as f:
                    f.write(json.dumps(status_info) + '\n')
                
                # 如果同步状态异常，发出警告
                if not sync_status.get('synced', False) and self.ntp_manager.role == 'client':
                    self.logger.warning(f"Time sync lost! Offset: {sync_status.get('offset_ms', 'unknown')}ms")
                
                # 如果GPS记录器意外停止，发出警告
                if self.enable_gps and gps_status == "stopped":
                    self.logger.warning("GPS logger stopped unexpectedly")
                
            except Exception as e:
                self.logger.error(f"Monitoring error: {e}")
            
            time.sleep(10)  # 每10秒检查一次
    
    def run_udp_sender(self):
        """运行UDP发送端"""
        self.logger.info("Starting UDP sender...")
        
        # 构建命令
        cmd = [
            'python3', 'udp_sender.py',
            '--local-ip', self.config.get('local_ip', '0.0.0.0'),
            '--local-port', str(self.config.get('local_port', 20002)),
            '--remote-ip', self.config.get('remote_ip', '192.168.104.20'),
            '--remote-port', str(self.config.get('remote_port', 20001)),
            '--packet-size', str(self.config.get('packet_size', 200)),
            '--frequency', str(self.config.get('frequency', 10)),
            '--time', str(self.config.get('running_time', 60)),
            '--log-path', self.log_path
        ]
        
        try:
            result = subprocess.run(cmd, check=True)
            self.logger.info("UDP sender completed successfully")
            return True
        except subprocess.CalledProcessError as e:
            self.logger.error(f"UDP sender failed: {e}")
            return False
    
    def run_udp_receiver(self):
        """运行UDP接收端"""
        self.logger.info("Starting UDP receiver...")
        
        # 构建命令
        cmd = [
            'python3', 'udp_receiver.py',
            '--local-ip', self.config.get('local_ip', '0.0.0.0'),
            '--local-port', str(self.config.get('local_port', 20001)),
            '--buffer-size', str(self.config.get('buffer_size', 1500)),
            '--time', str(self.config.get('running_time', 3600)),
            '--log-path', self.log_path
        ]
        
        try:
            result = subprocess.run(cmd, check=True)
            self.logger.info("UDP receiver completed successfully")
            return True
        except subprocess.CalledProcessError as e:
            self.logger.error(f"UDP receiver failed: {e}")
            return False
    
    def run_test(self):
        """运行完整测试"""
        try:
            print("=" * 60)
            print("无人机UDP通信测试系统 - 集成NTP时间同步")
            print("=" * 60)
            
            # 1. 设置时间同步
            print("\n1. 设置时间同步...")
            if not self.ntp_manager.setup_time_sync():
                print("✗ 时间同步设置失败，测试终止")
                return False
            
            # 2. 启动GPS记录器
            if self.enable_gps:
                print("\n2. 启动GPS记录器...")
                if not self.start_gps_logging():
                    print("✗ GPS记录器启动失败，继续测试...")
                else:
                    print("✓ GPS记录器启动成功")
            
            # 3. 启动状态监控
            print(f"\n{3 if not self.enable_gps else 3}. 启动状态监控...")
            self.start_monitoring()
            
            # 4. 等待同步稳定
            print(f"\n{4 if not self.enable_gps else 4}. 等待时间同步稳定...")
            time.sleep(10)
            
            # 5. 运行UDP测试
            print(f"\n{5 if not self.enable_gps else 5}. 运行UDP测试 (模式: {self.mode})...")
            
            if self.mode == 'sender':
                success = self.run_udp_sender()
            elif self.mode == 'receiver':
                success = self.run_udp_receiver()
            else:
                self.logger.error(f"Unknown mode: {self.mode}")
                return False
            
            # 6. 停止GPS记录器
            if self.enable_gps:
                print(f"\n{6 if not self.enable_gps else 6}. 停止GPS记录器...")
                self.stop_gps_logging()
            
            # 7. 停止监控
            print(f"\n{7 if not self.enable_gps else 7}. 停止状态监控...")
            self.stop_monitoring()
            
            if success:
                print(f"\n✓ 测试完成！日志保存在: {self.log_path}")
                return True
            else:
                print("\n✗ 测试失败！")
                return False
                
        except KeyboardInterrupt:
            print("\n测试被用户中断")
            if self.enable_gps:
                self.stop_gps_logging()
            self.stop_monitoring()
            return False
        except Exception as e:
            self.logger.error(f"Test failed: {e}")
            if self.enable_gps:
                self.stop_gps_logging()
            self.stop_monitoring()
            return False


def main():
    """主函数"""
    parser = argparse.ArgumentParser(description='无人机UDP通信测试系统 - 集成NTP时间同步')
    
    # 基本参数
    parser.add_argument('--mode', choices=['sender', 'receiver'], required=True,
                       help='运行模式: sender(发送端) 或 receiver(接收端)')
    parser.add_argument('--local-ip', default='192.168.104.10',
                       help='本地IP地址 (默认: 192.168.104.10)')
    parser.add_argument('--peer-ip', default='192.168.104.20',
                       help='对方IP地址 (默认: 192.168.104.20)')
    parser.add_argument('--log-path', default='./logs',
                       help='日志保存路径 (默认: ./logs)')
    
    # UDP发送端参数
    parser.add_argument('--remote-ip', 
                       help='远程IP地址 (发送端使用，默认为peer-ip)')
    parser.add_argument('--remote-port', type=int, default=20001,
                       help='远程端口 (默认: 20001)')
    parser.add_argument('--local-port', type=int, default=20002,
                       help='本地端口 (默认: 20002)')
    parser.add_argument('--packet-size', type=int, default=200,
                       help='数据包大小(字节) (默认: 200)')
    parser.add_argument('--frequency', type=float, default=10.0,
                       help='发送频率(Hz) (默认: 10.0)')
    parser.add_argument('--running-time', type=int, default=60,
                       help='运行时间(秒) (默认: 60)')
    
    # UDP接收端参数
    parser.add_argument('--buffer-size', type=int, default=1500,
                       help='缓冲区大小(字节) (默认: 1500)')
    
    # GPS记录参数
    parser.add_argument('--enable-gps', action='store_true',
                       help='启用GPS数据记录')
    parser.add_argument('--drone-id', default='drone0',
                       help='无人机命名空间 (默认: drone0)')
    parser.add_argument('--gps-interval', type=float, default=1.0,
                       help='GPS记录间隔(秒) (默认: 1.0)')
    parser.add_argument('--use-sim-time', action='store_true',
                       help='使用仿真时间')
    
    args = parser.parse_args()
    
    # 构建配置
    config = {
        'mode': args.mode,
        'local_ip': args.local_ip,
        'peer_ip': args.peer_ip,
        'log_path': args.log_path,
        'remote_ip': args.remote_ip or args.peer_ip,
        'remote_port': args.remote_port,
        'local_port': args.local_port if args.mode == 'sender' else args.remote_port,
        'packet_size': args.packet_size,
        'frequency': args.frequency,
        'running_time': args.running_time,
        'buffer_size': args.buffer_size,
        'enable_gps': args.enable_gps,
        'drone_id': args.drone_id,
        'gps_interval': args.gps_interval,
        'use_sim_time': args.use_sim_time,
    }
    
    # 调整接收端的端口配置
    if args.mode == 'receiver':
        config['local_port'] = args.remote_port  # 接收端监听remote_port
    
    # 创建并运行测试管理器
    test_manager = UDPTestManager(config)
    success = test_manager.run_test()
    
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main() 